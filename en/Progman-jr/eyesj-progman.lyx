#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options false
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 4
\tocdepth 4
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\size tiny
.
\size giant

\begin_inset Newline newline
\end_inset


\begin_inset VSpace 1in
\end_inset

ExpEYES-Junior
\end_layout

\begin_layout Standard
\align center

\size giant
Programmer's Manual
\end_layout

\begin_layout Standard
\begin_inset VSpace 1in
\end_inset


\end_layout

\begin_layout Standard
\align center

\size larger
Ajith Kumar B.P
\end_layout

\begin_layout Standard
\align center

\size larger
Inter-University Accelerator Centre
\end_layout

\begin_layout Standard
\align center

\size larger
New Delhi 110 067
\end_layout

\begin_layout Standard
\begin_inset VSpace 1in
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 1in
\end_inset


\end_layout

\begin_layout Standard
\align center
Version 1.1 (26-Oct-2013)
\end_layout

\begin_layout Standard
\align center
http://expeyes.in
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The design of expEYES is shown schematically in figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:expEYES-Junior-Top"

\end_inset

, along with the top panel marking the Input/Output connectors explained
 in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Description-of-Input/Output"

\end_inset

.
 Functions for accessing the feature of the expEYES hardware, like measuring
 a voltage or frequency, setting a voltage or frequency, measuring time
 intervals etc.
 are available in Python and C languages.
 Data analysis and graphics functions are given in two separate Python modules.
 Application programs are developed using these modules.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/top-panel.png
	lyxscale 30
	width 5cm

\end_inset

 
\begin_inset Graphics
	filename pics/eyesjun-block.png
	lyxscale 50
	width 6cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
expEYES Junior Top panel and Block diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:expEYES-Junior-Top"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pin #
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ground
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5V range Analog /Digital Input, Current Source
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5V range Analog / Digital Input, Current Source
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5V range Analog/Digital Input, with 5K pullup, for resistive sensors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.7Hz to 200kHz Square Wave Output, 
\begin_inset Formula $100\Omega$
\end_inset

 series resistor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.7Hz to 200kHz Square Wave Output, no series resistor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OD1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Digital Output, no series resistor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CCS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 mA Constant Current Source with ON/OFF Control
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ground
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ground
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SINE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sinewave output, around 150 Hz, 4 volts
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MIC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Output of the microphone, amplified 51 times
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inverting Amplifier Input, maximum gain = 51
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OUT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Amplifier output, of Pin13
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PVS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Programmable Voltage Output, from 0 to 5 volts.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\pm5V$
\end_inset

 range Analog Input
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\pm5V$
\end_inset

 range Analog Input
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GND
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ground
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Description of Input/Output Terminals
\begin_inset CommandInset label
LatexCommand label
name "tab:Description-of-Input/Output"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Software
\end_layout

\begin_layout Standard
There are mainly three modules under the expeyes package:
\end_layout

\begin_layout Itemize
eyesj.py : hardware communication
\end_layout

\begin_layout Itemize
eyeplot.py : Graphics using using Tkinter module
\end_layout

\begin_layout Itemize
eyemath.py : data analysis using modules numpy and scipy
\end_layout

\begin_layout Itemize
ejlib.c & ejlib.h : C library and the header file
\end_layout

\begin_layout Standard
They can be installed by using the .tgz files or the .deb packages provided
 on http://expeyes.in.
\end_layout

\begin_layout Chapter
Hardware Communication
\end_layout

\begin_layout Standard
The module expeyes.py contains all the functions required for communicating
 to the hardware in addition to some utility functions.
 The functions are inside a class and the open() function returns an object
 of this class if expEYES hardware is detected.
 After that the function calls to access expEYES are done using this object,
 as shown in the example below.
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj      # import the eyes library
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()  # returns an object if hardware is found
\end_layout

\begin_layout LyX-Code
print p.get_voltage(1)    # print the voltage at input A1
\end_layout

\begin_layout Standard
A sample program in C language is given below.
 This should be compiled and executed.
\end_layout

\begin_layout LyX-Code
#include "ejlib.c"
\end_layout

\begin_layout LyX-Code
int fd;
\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
   byte ss[10]; 
\end_layout

\begin_layout LyX-Code
   fd = open_eyesj(); 
\end_layout

\begin_layout LyX-Code
   if(fd < 0) 
\end_layout

\begin_layout LyX-Code
     {
\end_layout

\begin_layout LyX-Code
     fprintf(stderr,"EYES Open Failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
     exit(0);
\end_layout

\begin_layout LyX-Code
     }
\end_layout

\begin_layout LyX-Code
   if(get_version(ss) != 0) exit(1);
\end_layout

\begin_layout LyX-Code
   printf(
\begin_inset Quotes eld
\end_inset

%s
\backslash
n
\begin_inset Quotes erd
\end_inset

,ss);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
On error, the Python functions returns None (-1 in the case of time interval
 measurements).
 On success the data is returned.
 The C functions returns zero on success, en errorcode otherwise.
 The data is always returned using the addresses passed to the function
 by the calling program.
 In both Python and C, the functions are given the same names.
 The main difference is in returning the results.
 In C, you need to pass an address for that.
 The function returns only the status of the operation.
 Some of the C functions are mentioned below.
 It is easier to have a look at the header file 
\shape italic
ejlib.h
\shape default
.
\end_layout

\begin_layout Standard
For every function, the Python and C versions are described, but no example
 code given in C.
 Every function communicates to the program running on the micro-controller
 on the expEYES Junior board.
 The hardware communication functions can be broadly grouped into analog
 inputs, analog outputs, digital inputs, digital outputs, time interval
 measurements, waveform generation etc.
 For plotting data from expEYES, the python-matplotlib package is used.
\end_layout

\begin_layout Standard
The following sections will introduce features of expEYES with examples.
 The voltages applied MUST be within the specified limits.
 
\emph on
A channel number is assigned to identify every Analog/Digital signal.
 The function calls uses this number for accessing it.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Channel #
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Analog Comparator output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR1 readback
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR2 readback
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR1 output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR1 output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OD1 output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CCS output control
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PVS Readback
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Signals and Channel Numbers
\begin_inset CommandInset label
LatexCommand label
name "tab:Signals-and-Channel"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Analog Output
\end_layout

\begin_layout Standard
The Programmable Voltage Sources (PVS) can be set anywhere between 0 and
 5 volts.
 The resolution is 12 bits, means the minimum step is 5000/4095, around
 1.25 millivolts.
\end_layout

\begin_layout Subsection
set_voltage()
\end_layout

\begin_layout Standard
Set the output voltage of the PVS.
 The value of 
\shape italic
V
\shape default
 should be in 0 to 5 volts range.
 The function returns the actual value set, by reading it back using an
 ADC input (channel number 12).
 
\end_layout

\begin_layout LyX-Code
print p.set_voltage(2.5)      # Sets 2.5 volts on PVS
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_voltage(float v, float* vset); // vset returns the readback of
 PVS
\end_layout

\begin_layout Section
Digital Inputs (IN1, IN2 and SEN)
\end_layout

\begin_layout Standard
You can connect them externally to GND or 5 volts , to make the voltage
 level HIGH or LOW.
 Any voltage less than 1 volt is taken as a LOW or 0.
 Anything greater than 2.5 volts is treated as a HIGH or 1.
 These terminals can also be configured as Analog Inputs.
 
\end_layout

\begin_layout Subsection
get_state(channel#)
\end_layout

\begin_layout Standard
Returns 0 or 1, depending on the voltage level at the input pin
\end_layout

\begin_layout LyX-Code
print p.get_state(3)    # prints logic level of IN1.
  IN2 = 4, SEN = 5
\end_layout

\begin_layout LyX-Code
print p.get_state(0)    # Returns 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 if SEN > 1.25 volts
\end_layout

\begin_layout Standard
Channel 0 represents the analog comparator output.
 The positive input of analog comparator should be connected to SEN.
 Negative input is internally connected to 1.25 volts.
\end_layout

\begin_layout Standard
One of the powerful feature of digital inputs is the ability to measure
 the time between level transitions with microsecond resolution.
 This will be discussed later.
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte get_state(byte pin, byte *st); // variable st returns 0 or 1.
\end_layout

\begin_layout Section
Digital Output (OD1)
\end_layout

\begin_layout Standard
You can set the voltage level on them to LOW or HIGH volts using software.
 If you connect LEDs to them, use a 1K
\begin_inset Formula $\Omega$
\end_inset

 series resistor for current limiting.
\end_layout

\begin_layout Subsection
set_state(channel#, state)
\end_layout

\begin_layout Standard
This function sets the specified channel to state 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout LyX-Code
\align block
p.set_state(10,1)    # Sets OD1 HIGH.
 Channel number of OD1 is 10
\end_layout

\begin_layout Standard
The outputs SQR1 (8) and SQR2 (9) also can behave as digital outputs, provided
 they are not configured to generate Square or PWM outputs.
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_state(byte pin, byte state); // pin is set to 0 or 1, according
 to the value of state.
\end_layout

\begin_layout Section
Analog Inputs (A1,A2,IN1,IN2 & SEN)
\end_layout

\begin_layout Standard
The analog inputs A1 and A2 accept voltages between -5 volts and +5 volts.
 The Inputs IN1, IN2 and SEN can accept voltages in the 0 to 5 volts range.
 We can read the voltage level at any of this inputs, either as single reads
 or multiple reads in a single function call, normally to capture a waveform.
 The time interval between consecutive reads within a capture can be set
 with microsecond resolution.
\end_layout

\begin_layout Subsection
get_voltage(channel#)
\end_layout

\begin_layout LyX-Code
print p.get_voltage(1)  # voltage at A1
\end_layout

\begin_layout LyX-Code
print p.get_voltage(2)  # voltage at A2
\end_layout

\begin_layout LyX-Code
print p.get_voltage(3)  # voltage at IN1
\end_layout

\begin_layout LyX-Code
print p.get_voltage(4)  # voltage at IN2
\end_layout

\begin_layout LyX-Code
print p.get_voltage(5)  # voltage at SEN
\end_layout

\begin_layout LyX-Code
print p.get_voltage(6)  # voltage at SQR1 output
\end_layout

\begin_layout LyX-Code
print p.get_voltage(7)  # voltage at SQR2 output
\end_layout

\begin_layout LyX-Code
print p.get_voltage(12) # voltage at PVS output
\end_layout

\begin_layout Standard
Connect PVS to A1 using a piece of wire and run the following program several
 times.
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
v = input('Enter V (0 to 5)')
\end_layout

\begin_layout LyX-Code
print p.set_voltage(v)   # prints the voltage set on PVS
\end_layout

\begin_layout LyX-Code
\align block
print p.get_voltage(1)   # voltage at A1
\end_layout

\begin_layout Standard
If the voltages are in the 0 to 5 volts range, use IN1 or IN2 for better
 results.
 The 
\begin_inset Formula $\pm5V$
\end_inset

 range inputs A1 & A2 are converted in to 0 to 5V range using summing junctions.
 The amplifiers used for this will have some gain and offset errors.
 The resolution also is halved because of the doubles total range.
 The input SEN has a 5k pullup resistor to 5 volts, for connecting photo-transis
tors and other resistive sensors .
 
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte get_voltage(byte ch, float* v)
\end_layout

\begin_layout Subsection
get_voltage_time(channel#)
\end_layout

\begin_layout Standard
This function returns the time stamp, from the PC clock, and the voltage
 in a tuple.
 This is useful for data logging applications.
 
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte get_voltage(byte ch, int* t, float* v)
\end_layout

\begin_layout Subsection
get_voltageNS(channel#)
\end_layout

\begin_layout Standard
The 
\emph on
get_voltage()
\emph default
 function mentioned in the previous section measures the voltage after putting
 the micro-controller is SLEEP mode, for better accuracy.
 This will stop waveforms set on SQR1 & SQR2.
 If that is not accepatble for a particular experiment, one can use this
 function.
\end_layout

\begin_layout LyX-Code
print p.get_voltageNS(1)  # voltage at A1
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte get_voltageNS(byte ch, float* v)
\end_layout

\begin_layout Subsection
capture(ch, NP, tg)
\end_layout

\begin_layout Standard
The argument 
\shape italic
ch
\shape default
 is the input channel number, 
\shape italic
NP
\shape default
 is the number of measurements and 
\shape italic
tg
\shape default
 is the time between two measurements in microseconds.
 Two lists containing the time (milliseconds) and voltage (volts) coordinates
 are returned by this function.
 Capture calls return analog data with 8 bit resolution.
 Maximum value of NP is 1800, limited by the micro-controller RAM available.
 
\end_layout

\begin_layout Standard
The minimum value of 'tg' is 4 microseconds.
 The value of 'tg' is decided by the frequency of the signal to be captured.
 For example, one cycle of a 1kHz sine wave is 1000 microseconds.
 A tg of 20 will give 50 data points per cycle.
\end_layout

\begin_layout Standard
Connect SINE to A1 and run the following program.
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
t,v = p.capture(1,300,100)
\end_layout

\begin_layout LyX-Code
plot(t,v)     # from pylab
\end_layout

\begin_layout LyX-Code
show()        # from pylab
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Terminal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Channel #
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range(V)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-5 to +5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-5 to +5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IN2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR1(read)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SQR2(read)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 to 5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
If the voltage to be measured is in the 0 to 5V range, use IN1 or IN2, for
 a better resolution.
 The SEN input has a 5
\begin_inset Formula $k\Omega$
\end_inset

 pullup resistor to 5V supply.
 We can calculate the value of a resistance connected from SEN to GND, from
 the measured voltage, using Ohm's law.
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte capture(int ch, int ns, int tg, float* data); 
\end_layout

\begin_layout Standard
The variable data returns an array of 2*ns float type elements, first ns
 time coordinates and after that ns voltage coordinates.
 It is the responsibility of the calling program to pass the address of
 an array having sufficient size.
 capture_hr() also returns data in the same format.
\end_layout

\begin_layout Subsection
capture2, capture3 & capture4
\end_layout

\begin_layout Standard
These functions captures multiple channels together, with timing correlation.
 The maximum value of NP for capture4 = 1800/4 = 450.
 The minimum value of 'tg' is 4 microseconds per channel, capture4 should
 have a minimum tg of 16.
\end_layout

\begin_layout LyX-Code
t1,v1,t2,v2 = capture2(ch1, ch2, NP, tg)
\end_layout

\begin_layout LyX-Code
t1,v1,t2,v2 = capture2_hr(ch1, ch2, NP, tg)
\end_layout

\begin_layout LyX-Code
t1,v1,t2,v2,t3,v3 = capture3(ch1, ch2, ch3, NP, tg)
\end_layout

\begin_layout LyX-Code
t1,v1,t2,v2,t3,v3,t4,v4 = capture4(ch1, ch2, ch3, ch4, NP, tg)
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte capture2(int ch1, int ch2, int ns, int tg, float* data); 
\end_layout

\begin_layout Standard
The variable data returns an arrays of 2(2*ns) float type elements.
 First (2*ns) are the time and voltage values for channel 1 and the next
 (2*ns) for channel 2.
 Function capture3 and capture4 also returns data in a similar manner.
\end_layout

\begin_layout Subsection
capture_hr(ch, NP, tg), capture2_hr(ch1, ch2, NP, tg)
\end_layout

\begin_layout Standard
These two functions captures data with higher resolution (12 bits).
 In this case each value takes 2 bytes and the maximum value of NP is 900
 for capture_hr, and 450 for capture2_hr.
 High resolution version is NOT available for capture3 and capture4.
\end_layout

\begin_layout LyX-Code
t1,v1 = capture_hr(ch1, 900, 10)
\end_layout

\begin_layout LyX-Code
t1,v1,t2,v2 = capture2_hr(ch1, ch2, 450, 20)
\end_layout

\begin_layout LyX-Code
plot(t1,v1, t2,v2)
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Standard
We can find out the amplitude and frequency of the input waveform by mathematica
lly fitting the captured data to the equation of a sine wave
\begin_inset Formula $V=V_{0}\sin\left(2\pi ft+\theta\right)+C$
\end_inset

 .
 By capturing 4 to 5 cycles, the frequency can be obtained within 0.1% error.
\end_layout

\begin_layout Section
Capture modifiers
\end_layout

\begin_layout Standard
When a periodic wave form is captured, the starting point could be at any
 voltage, within the minimum and maximum voltage.
 To implement an oscilloscope, we need to make sure that the starting point
 is always same, else the trace will be jumping around.
 This is a simple example of a capture modifier.
 expEYES implements several other types of capture modifiers to enhance
 the functionality of the capture functions.
 The basic idea is to perform some action just before starting the waveform
 capture.
 The important types of modifiers (or actions) are
\end_layout

\begin_layout Itemize
Analog Trigger on any input channel, trigger level can be set by the user.
\end_layout

\begin_layout Itemize
Wait for HIGH, LOW, Falling Edge or Rising Edge on Inputs IN1, IN2, SEN,
 SQR1 or SQR2
\end_layout

\begin_layout Itemize
Set, Clear or send Pulse one of the Digital Outputs, mainly OD1.
 SQR1 & SQR2 also will act as digital outputs if frequency is set to zero.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AANATRIG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trigger on analog input level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASET
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Makes the specified Output HIGH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ACLR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Makes the specified Output LOW
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
APULSEHT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Send High True Pulse on Output 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
APULSELT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Send Low True Pulse on Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AWAITHI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wait for HIGH level on specified Input
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AWAITLO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wait for LOW level on specified Input
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AWAITRISE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wait for Rising Edge on specified Input
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AWAITFALL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wait for Falling Edge on specified Input
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Capture Modifiers
\begin_inset CommandInset label
LatexCommand label
name "tab:Capture-Modifiers"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
enable_action(action, Selected I/O) is the function call for registering
 actions.
 They will be valid on subsequent capture calls.
 Calling disable_actions() removes all registered actions and capture goes
 back to its default state of analog triggering on the captured channel.
 For convenience, we have defined more functions that internally call the
 function enable_action()
\end_layout

\begin_layout Subsection
set_trigger(trigval)
\end_layout

\begin_layout Standard
Sets the analog voltage trigger level, for the capture function.
 If the specified voltage value is not found at the input, within the timeout
 period, the capture is done ignoring the trigger condition.
\end_layout

\begin_layout LyX-Code
p.set_trigger(2048)   # 0 to 4095 is the analog range
\end_layout

\begin_layout Subsection
set_trigsource(channel#)
\end_layout

\begin_layout Standard
The Input source to be used for analog level triggering.
 It need not be the one that is captured.
 The example code below demonstrates the effect of this function.
 Connect SINE to A1 before running.
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
ts = 1      # run the program by changing this to 2
\end_layout

\begin_layout LyX-Code
p.set_trig_source(ts)
\end_layout

\begin_layout LyX-Code
t,v = p.capture(1,300,50)
\end_layout

\begin_layout LyX-Code
plot(t,v)
\end_layout

\begin_layout LyX-Code
t,v = p.capture(1,300,50)
\end_layout

\begin_layout LyX-Code
plot(t,v)
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Standard
The traces will not overlap if the trigger source is set to some other channel,
 provided there is no time correlation between the two inputs.
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_trig_source(byte ch);
\end_layout

\begin_layout Subsection
enable_wait_high(channel#), ..._low(...), ..._falling(...), ..._rising(...)
\end_layout

\begin_layout Standard
Calling this function makes all the subsequent 
\series bold
capture
\series default
 calls to wait for a HIGH / LOW / rising edge/ falling edge, on the specified
 input before starting the digitization.
\end_layout

\begin_layout LyX-Code
p.enable_action(1, 11)    # Start CCS before capturing
\end_layout

\begin_layout LyX-Code
p.enable_wait_rising(3)   # wait for a rising edge on IN1
\end_layout

\begin_layout LyX-Code
p.disable_actions()       # removes all modifiers
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte enable_wait_high(byte ch);
\end_layout

\begin_layout Subsection
enable_set_high(channel#), ..._low(...), ..._pulse_high(...), ..._low(...)
\end_layout

\begin_layout Standard
In some applications, it would be necessary to make a digital output high/low
 or send a pulse, width set by another function, with before digitization
 starts.
 Capturing the voltage across a capacitor while charging / discharging is
 a typical application of this feature.
 Connect a 1uF capacitor between A1 and GND.
 Connect a 1K
\begin_inset Formula $\Omega$
\end_inset

 resistor from OD1 to A1 and run the following code.
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_state(10,1)        # Take OD1 HIGH
\end_layout

\begin_layout LyX-Code
p.enable_set_low(10)     # OD1 go LOW before capture
\end_layout

\begin_layout LyX-Code
t,v = p.capture(1,200,20)
\end_layout

\begin_layout LyX-Code
plot(t,v)
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte enable_set_high(byte ch);
\end_layout

\begin_layout Subsection
set_pulsewidth(width)
\end_layout

\begin_layout Standard
Sets the width of the pulse that is send on the digital outputs before capturing
, in microseconds, up to 250.
\end_layout

\begin_layout LyX-Code
p.set_pulsewidth(100)  # sets the pulsewidth
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_pulsewidth(u16 width);
\end_layout

\begin_layout Section
Waveform Generation
\end_layout

\begin_layout Standard
ExpEYES can generate square waves on SQR1 and SQR2.
 The frequency can vary from 0.7 Hz to 100 kHz.
 All intermediate values are NOT possible since the output is generated
 by timers and comparators.
 The function returns the actual values set, closest possible to the requested.
 Output SQR1 has a 
\begin_inset Formula $100\Omega$
\end_inset

 series resistor for current limiting, but SQR2 is directly connected.
\end_layout

\begin_layout Subsection
set_sqr1(freq), set_sqr2(freq)
\end_layout

\begin_layout Standard
Generates a square waveform, having 50% duty cycle, on SQR1/SQR2.
 SQR1 has a 100
\begin_inset Formula $\Omega$
\end_inset

 series resistor on it.
 Setting freq = 0 will make the output HIGH and setting freq = -1 will make
 it LOW.
 Both these cases disables the Timer/Counter and configures it as a normal
 digital output.
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
\align block
print p.set_sqr1(1000) 
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_sqr1(float freq, float *fset);
\end_layout

\begin_layout Standard
The desired value is specified in 'freq', after the call 'fset' will contain
 the actual frequency set.
\end_layout

\begin_layout Subsection
set_sqrs(freq, phase shift in percent)
\end_layout

\begin_layout Standard
Generates a square waveform of same frequency on both SQR1 and SQR2.
 The phase shift between the two can be set in percentage of the Time Period.
\end_layout

\begin_layout LyX-Code
\align block
p.set_sqrs(1000,50)    # Two out of phase waveforms 
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_sqrs(float freq, float diff, float *fset);
\end_layout

\begin_layout Subsection
set_sqr1_pwm(dutycycle), set_sqr2_pwm(dutycycle)
\end_layout

\begin_layout Standard
SQR1 and SQR2 can be configured for making Pulse Width Modulated waveform.
 The duty cycle is specified in percentage.
 The frequency is 488Hz by default, because the second argument is set to
 14 by default.
 This is the index of counter's bit which triggers the PWM.
 Specifying the second argument can be used for changing the frequency.
 Reducing it by 1 will double the frequency and increasing by 1 will halve
 it.
\end_layout

\begin_layout LyX-Code
\align block
print p.set_sqr1_pwm(20)      # 488Hz, 20% duty cycle 
\end_layout

\begin_layout LyX-Code
\align block
print p.set_sqr1_pwm(50, 15)  # 244Hz, 50% duty cycle
\end_layout

\begin_layout LyX-Code
\align block
print p.set_sqr1_pwm(50, 13)  # 976Hz, 50% duty cycle 
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_sqr1_pwm(byte dc);
\end_layout

\begin_layout Subsection
set_sqr1_dc(voltage), set_sqr2_dc(voltage)
\end_layout

\begin_layout Standard
SQR1 and SQR2 can be configured to generate a DC voltage, by external filtering,
 from a PWM waveform.
 The voltage, 0 to 5V range, is specified as the argument.
\end_layout

\begin_layout LyX-Code
\align block
print p.set_sqr1_dc(2)   # 7.8 kHz, 40% duty cycle 
\end_layout

\begin_layout Standard
\align block
Filtering the waveform generates a DC voltage.
 Connect 10k from SQR1 to IN1 and 100uF from IN1 to GND.
\end_layout

\begin_layout LyX-Code
print p.get_voltage(3)   # voltage at IN1
\end_layout

\begin_layout Standard
The output voltage depends on the supply voltage provided by USB.
 Setting 3 volts means only setting 60% of the supply voltage.
 The readout from IN1 will give the correct value.
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte set_sqr1_dc(float volt)
\end_layout

\begin_layout Subsection
get_frequency(pin)
\end_layout

\begin_layout Standard
Measure the frequency of a 0 to 5V square wave connected to IN1, IN2 or
 SEN.
 You can also measure the frequency of SQR1 & SQR2 outputs from channels
 6 and 7 respectively.
 Connect SQR1 to IN1 and run the following code
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_sqr1(1000)
\end_layout

\begin_layout LyX-Code
print p.get_frequency(3)      # frequency of squarewave at IN1
\end_layout

\begin_layout LyX-Code
print p.get_frequency(6)      # frequency of SQR1, same as above
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte get_frequency(byte pin, float *fr)
\end_layout

\begin_layout Section
Infrared Transmission
\end_layout

\begin_layout Standard
The SQR1 output supports two types of 38kHz infrared transmission protocol.
 One is a non-standard 1 byte transmission, that can be received by another
 program running on an ATmega32 micro-controller.
 This can be used for controlling some device from expEYES junior.
\end_layout

\begin_layout Subsection
irsend1(byte)
\end_layout

\begin_layout Standard
Sends the byte over SQR1.
 Just connect an IR LED from SQR1 to GND and issue the command.
\end_layout

\begin_layout Standard
To signify a start 38kHz is kept on for 9000 microseconds followed by a
 silence of 4400 microseconds.
 After that 38kHz is kept ON for 680 usec followed by (a) silence of 1560
 usecs to transmit a 1 and 440 usecs to transmit a 0.
 This process is repeated 8 times, starting with the MSB of the byte to
 be transmitted.
 The sequence ends by transmitting a 340 usecs long burst again.
 This is received by a program
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://expeyes.in/sites/default/files/debs/recv.c
\end_layout

\end_inset

 given on the website.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename schematics/ir-code.png
	height 1.5cm

\end_inset


\end_layout

\begin_layout Subsection
irsend4(byte, byte, byte, byte)
\end_layout

\begin_layout Standard
The Start and End are identical to irsend1() but instead of 1 byte, 4 bytes
 are sent in a single transmission.
 If the numbers are chosen properly, you can control TVs or other instruments
 using this.
\end_layout

\begin_layout Section
Passive Time Interval Measurements
\end_layout

\begin_layout Standard
Digital Inputs can be used for measuring time intervals between level transition
s on the digital inputs with microsecond resolution.
 The transitions defining the start and finish could be on the same terminal
 or on different ones.
\end_layout

\begin_layout Subsection
r2ftime(pin1, pin2) , f2rtime(pin1, pin2)
\end_layout

\begin_layout Standard
r2ftime returns delay in microseconds from a rising edge on pin1 to a falling
 edge on pin2, the channel numbers corresponding to the inputs should be
 given as the arguments.
 The pins could be same or distinct.
 Similarly f2rtime() measures time from a falling edge to a rising edge.
\end_layout

\begin_layout Standard
Connect SQR1 to IN1 and run the following code, should print around 500
 usecs.
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_sqr1(1000)        # 1kHz, T=1msec.
 half period = 500 usecs
\end_layout

\begin_layout LyX-Code
print p.r2ftime(3,3)
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte r2ftime(byte pin1, byte pin2, float *ti)
\end_layout

\begin_layout Subsection
r2rtime(pin1, pin2), f2ftime(pin1, pin2)
\end_layout

\begin_layout Standard
r2rtime returns delay in microseconds from a rising edge to rising edge.
 The pins should NOT be the same.
 The following code shows how to use this for measuring delay between two
 transitions.
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_sqrs(1000, 25)      # 1000Hz on both SQR1 & 2.
 Delay by 25%, 250us
\end_layout

\begin_layout LyX-Code
print p.r2rtime(6,7)      # Channels 6 & 7 are readback of SQR1 and SQR2
\end_layout

\begin_layout Subsection
multi_r2rtime(channel#,skip_edges)
\end_layout

\begin_layout Standard
Measures time interval between two rising edges of a waveform applied to
 a digital input.
 The second argument is the number of rising edges to be skipped between
 the two measured rising edges.
 This way we can decide the number of cycles to be measured.
\end_layout

\begin_layout Standard
Connect SQ1to IN1 and run the following code.
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_sqr1(1000)
\end_layout

\begin_layout LyX-Code
a = p.multi_r2rtime(3)      # time for 1 cycle in usecs
\end_layout

\begin_layout LyX-Code
b = p.multi_r2rtime(3,9) # time for 10 cycles in usecs
\end_layout

\begin_layout LyX-Code
print 10.0e6/a  # frequency in Hz
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
For a periodic waveform input, the fourth line of the program returns the
 time for one cycle and the fifth one returns the time for 10 cycles ( 9
 rising edges in between skipped).
 This call can be used for frequency measurement.
 The accuracy can be improved by measuring larges number of cycles.
\end_layout

\begin_layout Paragraph*
C function:
\end_layout

\begin_layout Standard
byte multi_r2rtime(byte pin, byte skip, float *ti)
\end_layout

\begin_layout Section
Active Time Interval Measurements
\end_layout

\begin_layout Standard
During some experiments, we need to initiate some action and measure the
 time interval to the result of of that action.
 These functions are used in experiments like gravity by time of flight
 and velocity of sound using ultrasound piezo discs.
\end_layout

\begin_layout Subsubsection
set2rtime (Digital Output, Digital Input)
\end_layout

\begin_layout Standard
This makes the specified Digital Output HIGH and waits for a HIGH on the
 Digital Input.
 Connect a 1k resistor from OD1 to IN1 and a 1uF capacitor from IN1 to GND.
 
\end_layout

\begin_layout Quotation
\align left
p.set2rtime(10, 3)
\end_layout

\begin_layout Subsubsection
htpulse2rtime(Digital output, Digital Input)
\end_layout

\begin_layout LyX-Code
int htpulse2rtime(out, in)
\end_layout

\begin_layout Standard
Sends out a single High True pulse on 
\series bold
out
\series default
 (SQR1, SQR2 or OD1) and waits for a rising/falling edge on 
\series bold
in
\series default
 (IN1, IN2 or SEN).
 The duration of the pulse is set by set_pulsewidth().
 On powerup the width is 13 microseconds.
 The initial level of 
\series bold
out
\series default
 should be set according to the kind of pulse.
\end_layout

\begin_layout Standard
Similarly we have htpulse2ftime(), ltpulse2rtime() and ltpulse2ftime().
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(1)
\end_layout

\begin_layout LyX-Code
print p.htpulse2rtime(10, 3) 
\end_layout

\begin_layout Standard
measures the time from a 1usec wide High True pulse on OD1 to a rising edge
 on IN1.
\end_layout

\begin_layout Subsubsection
set_pulse_width(width)
\end_layout

\begin_layout Standard
Sets the pulse width, in microseconds, to be used by the htpulse2rtime(),
 htpulse2ftime(), ltpulse2rtime(), ltpulse2ftime() functions.
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(10)
\end_layout

\begin_layout Section
1mA Current Source
\end_layout

\begin_layout Standard
The 1mA constant current can be switched ON or OFF by channel number 11,
 as shown below
\end_layout

\begin_layout LyX-Code
p.set_state(11, 1)    # switch on CCS 
\end_layout

\begin_layout Standard
We can plot the linear charging of a 1uF capacitor by conecting it between
 CCS and GND, and running the following code.
 Connect CCS to IN1 for voltage measurement.
\end_layout

\begin_layout LyX-Code
from pylab import * 
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj, time 
\end_layout

\begin_layout LyX-Code
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_state(11,0)      # switch of CCS
\end_layout

\begin_layout LyX-Code
time.sleep(1)          # wait for discharge
\end_layout

\begin_layout LyX-Code
p.enable_set_high(11)  # enable CCS just before capture   
\end_layout

\begin_layout LyX-Code
t1,v1= p.capture_hr(3,500,10) 
\end_layout

\begin_layout LyX-Code
plot(t1,v1) 
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Section
Capacitance measurements
\end_layout

\begin_layout Standard
The IN1 pin can be used for measuring capacitance, ranging from hundred
 to several thousand pico Farads.
 This is done using an internal programmable constant current source.
 
\end_layout

\begin_layout Subsection
measure_cap()
\end_layout

\begin_layout Standard
Connect the capacitor between IN1 and ground and run the function measure_cap().
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj
\end_layout

\begin_layout LyX-Code
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
print p.measure_cap()
\end_layout

\begin_layout Standard
The capacitance is measured by charging the capacitor with a 5.5 uA constant
 current source for a fixed duration.
 The total charge is given by Q = It = CV.
 If V,I and t are known, C can be calculated.
 The value of the current source may vary from 5.5 uA and the empty socket,
 along with tracks, also has some capacitance.
 These error are taken can by calibrating it using a known capacitor.
 The error factors are stored in EEPROM of the micro-controller.
\end_layout

\begin_layout Subsection
measure_cv(channel, duration, current)
\end_layout

\begin_layout Standard
This is a more flexible version of measure_cap, allowing to set the current
 source on IN1 or IN2.
 The current source is activated for 'duration' microseconds.
 The last argument could be .55, 5.5, 55 or 550 microamps.
 The function returns the voltage at the selected input after applying the
 current for the specified duration.
\end_layout

\begin_layout Standard
Depending on the value of the capacitor connected, we need to select duration
 and current such that the voltage developed is between 2 to 4 volts for
 good results.
 Connect a 330 pF capacitor from IN1 to GND and run the following code.
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj
\end_layout

\begin_layout LyX-Code
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
print p.measure_cv(3, 200, 5.5)  # result was 3.017 volts
\end_layout

\begin_layout Standard
The capacitance can be calculated using the expressions Q =CV and Q = I*t.
 C =I*t/v = 5.5*200/3.017 = 364 pF.
 Subtracting the Stray capacitance 32pF gives a result of 332pF.
\end_layout

\begin_layout Subsection
set_current(channel, current)
\end_layout

\begin_layout Standard
This function enables the internal current source on IN1 or IN2.
 This Constant Current Source may be used for measuring the current with
 some other device.
 The voltage readback is not working as expected.
 Using an ammeter connected from IN1 to ground, it is found that the current
 is 5.5 uA , 47 uA and 450 uA, somewhat less than the specification, in higher
 ranges.
\end_layout

\begin_layout Section
Resistance Measurements
\end_layout

\begin_layout Standard
The SEN input is internally connected to 5 volts through a 5100
\begin_inset Formula $\Omega$
\end_inset

 resistor.
 It is possible to calculate the value of a resistor connected from SEN
 to GND using Ohm's law.
 However, the internal resistor may not be exactly 5100 due to component
 tolerance.
\end_layout

\begin_layout Subsection
measure_res()
\end_layout

\begin_layout Standard
The input SEN is connected to 5 volts internally through a 5100 Ohm resistor.
 Connecting an external resistor from SEN to GND makes a potential divider.
 It is possible to calculate the value of the resistor connected using Ohm's
 law.
\end_layout

\begin_layout Standard
This function returns the value of a resistance connected from SEN to GND,
 calculated using the equation
\end_layout

\begin_layout Standard
\begin_inset Formula $R_{ext}=R_{int}*V{}_{SEN}/(5.0-V_{SEN})$
\end_inset


\end_layout

\begin_layout Section
Disk Writing
\end_layout

\begin_layout Subsection
save_data
\end_layout

\begin_layout Standard
Input data is of the form, [ [x1,y1], [x2,y2],....] where x and y are vectors,
 are save to a text file.
\end_layout

\begin_layout Standard
Save the data returned by the capture functions into a text file.
 Default filename is `plot.dat', that can be overriden by the second argument.
 Connect SINE to A1 and run the following code.
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj    
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
t,v = p.capture(1, 200, 100)
\end_layout

\begin_layout LyX-Code
p.save([[t,v]], 'sine.dat')
\end_layout

\begin_layout Standard
open the file using the command 
\end_layout

\begin_layout Standard
$xmgrace sine.dat
\end_layout

\begin_layout Chapter
Data processing
\end_layout

\begin_layout Standard
The data acquired from expEYES hardware is analyzed using various mathematical
 techniques like least-square fitting, Fourier transform etc.
 The module named eyemath.py does this with the help of functions from the
 'scipy' package.
 Most of the functions accepts the data format returned by capture functions.
 
\end_layout

\begin_layout Subsection
fit_sine
\end_layout

\begin_layout Standard
Accepts two vectors [x] and [y] and tries to do a least-square fitting of
 the data with the equation 
\begin_inset Formula $A\sin\left(2\pi ft+\theta\right)+C$
\end_inset

.
 Returns the fitted data and the parameter list
\begin_inset Formula $[A,f,\theta,C]$
\end_inset

.
 Connect SINE to A1 and run the following code.
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj, expeyes.eyemath as em
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
t,v= p.capture(1,400,100)
\end_layout

\begin_layout LyX-Code
vfit, par = em.fit_sine(t,v)
\end_layout

\begin_layout LyX-Code
print par        # 
\begin_inset Formula $A,f,\theta,C$
\end_inset


\end_layout

\begin_layout LyX-Code
plot(t,v)        # The raw data
\end_layout

\begin_layout LyX-Code
plot(t,vfit)     # data calculated from par
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Standard
par[1] is frequency in kHz, since the time is given in milliseconds.
\end_layout

\begin_layout Subsection
fit_dsine
\end_layout

\begin_layout Standard
Accepts two vectors [x] and [y] and tries to do a least-square fitting of
 the data with the equation 
\begin_inset Formula $A=A_{0}\sin\left(2\pi ft+\theta\right)\times exp(-dt)+C$
\end_inset

.
 Returns the fitted data and the parameter list
\begin_inset Formula $[A,f,\theta,C,d]$
\end_inset

.
 par[1] is frequency in kHz, since the time is given in milliseconds and
 'd' is the damping factor.
\end_layout

\begin_layout Subsection
fit_exp
\end_layout

\begin_layout Standard
Accepts two vectors [x] and [y] and tries to do a least-square fitting of
 the data with the equation 
\begin_inset Formula $A=A_{0}\exp\left(kt\right)+C$
\end_inset

.
 Returns the fitted data and the parameter list
\begin_inset Formula $[A,k,C]$
\end_inset

.
 Connect a 1uF capacitor from A1 to GND, 1k
\begin_inset Formula $\Omega$
\end_inset

 resistor from OD1 to A1 and run the following code.
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
\align block
import expeyes.eyesj, expeyes.eyemath as em
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_state(10,1)     # Take OD1 HIGH
\end_layout

\begin_layout LyX-Code
p.enable_set_low(10)    # OD1 go LOW before capture
\end_layout

\begin_layout LyX-Code
t,v = p.capture(1,200,20)
\end_layout

\begin_layout LyX-Code
plot(t,v)
\end_layout

\begin_layout LyX-Code
vfit, par = em.fit_exp(t,v)
\end_layout

\begin_layout LyX-Code
print par
\end_layout

\begin_layout LyX-Code
plot(t,v)        # The raw data
\end_layout

\begin_layout LyX-Code
plot(t,vfit)     # data calculated from par
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Standard
-(1/par[1]) is the time constant RC in seconds.
\end_layout

\begin_layout Subsubsection
fft
\end_layout

\begin_layout Standard
Does a Fourier transform of a given data set.
 The sampling interval in milliseconds is the second argument.
 Returns the frequency spectrum, ie.
 the relative strength of each frequency component.
 Connect SINE to A1 and run the following code.
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj, expeyes.eyemath as em
\end_layout

\begin_layout LyX-Code
ns = 1000   # number of points to be captured
\end_layout

\begin_layout LyX-Code
tg = 100    # time between reads in usecs
\end_layout

\begin_layout LyX-Code
\align block
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
t,v= p.capture(1, ns, tg)
\end_layout

\begin_layout LyX-Code
x,y = em.fft(v, tg * 0.001)  # tg in millisecs
\end_layout

\begin_layout LyX-Code
plot(t,v)     # The raw data
\end_layout

\begin_layout LyX-Code
plot(x,y)     # data calculated from par
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout Standard
The frequency spectrum should feature a peak at frequency f=150Hz.
 A small peak at frequency 2f may be visible.
\end_layout

\begin_layout Standard
Modify this program to show the frequency spectrum of a square wave.
\end_layout

\begin_layout Chapter
Experiments 
\end_layout

\begin_layout Standard
Most of the experiments described in the user manual can be done by writing
 few lines of Python code.
\end_layout

\begin_layout Section
Transient response of LC circuit
\end_layout

\begin_layout Standard
Connect inductor from OD1 to A1, capacitor from A1 to GND.
 
\end_layout

\begin_layout LyX-Code
NP = 200   # number of readings
\end_layout

\begin_layout LyX-Code
tg = 10    # time gap between them, keep NP*tg around 3*RC
\end_layout

\begin_layout LyX-Code
from pylab import *
\end_layout

\begin_layout LyX-Code
import expeyes.eyesj, expeyes.eyemath as em
\end_layout

\begin_layout LyX-Code
p = expeyes.eyesj.open()
\end_layout

\begin_layout LyX-Code
p.set_state(10,1)
\end_layout

\begin_layout LyX-Code
p.enable_set_low(10)           # OD1 go LOW before capture
\end_layout

\begin_layout LyX-Code
t,v = p.capture_hr(1,NP,tg)    # choose NP*tg according to time constant
\end_layout

\begin_layout LyX-Code
plot(t,v)
\end_layout

\begin_layout LyX-Code
vf, par = em.fit_exp(t,v)      # exponential fit
\end_layout

\begin_layout LyX-Code
plot(t, vf,'r')
\end_layout

\begin_layout LyX-Code
print abs(1./par[1])           # print RC value
\end_layout

\begin_layout LyX-Code
show()
\end_layout

\begin_layout LyX-Code

\end_layout

\end_body
\end_document
